<!-- import jquery library -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<!-- import paho MQTT library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<!-- import bootStrap library -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>


<script src="../uPlot Testing/dist/uPlot.iife.js"></script>
<script src="../uPlot Testing/node_modules/gridstack/dist/gridstack-all.js"></script>
<link rel="stylesheet" href="../uPlot Testing/node_modules/gridstack/dist/gridstack-extra.min.css"/>
<link href="../uPlot Testing/node_modules/gridstack/dist/gridstack.min.css" rel="stylesheet"/>
<script src="../uPlot Testing/dist/uPlot.iife.js"></script>
<link rel="stylesheet" href="../uPlot Testing/node-modules/gridstack/dist/demo.css"/>
<link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
<style type="text/css">
    .grid-stack { background: #F4F4F4; }
    .grid-stack-item-content { background-color: #FFFFFF; }
</style>

<html>
<head>
    <meta charset="utf-8">
    <title>Data Stream</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
</head>

<body>
<div class="container-fluid">
    <div>
        <a onClick="addWidget()" class="btn btn-primary" href="#">Add Widget</a>
    </div>
    <br>

    <div class="row" style="margin-top: 20px">
        <!--
        <div class="col-2" >
            <div class="grid-stack" id="seriesGrid"></div>
        </div>
        -->
        <div class="col-2">
            <div class="sidebar">
                <!-- will size to match content -->
                <div class="grid-stack-item">
                    <div class="grid-stack-item-content">Series 1</div>
                </div>
                <!-- manually force a drop size of 2x1 -->
                <div class="grid-stack-item" gs-w="2" gs-h="1" gs-max-w="3">
                    <div class="grid-stack-item-content">2x1, max=3</div>
                </div>
            </div>
        </div>
        <div class="col-10" >
            <div class="grid-stack" id="plotGrid"></div>
        </div>
    </div>


</div>
<script>
    let maxDataEntries = 100;
    let numItems = 0;


    let options = {
        minRow: 1,
        disableOneColumnMode: true,
        float: true,
        acceptWidgets: false
        //removable: '.trash', // true or drag-out delete class
        // itemClass: 'with-lines', // test a custom additional class #2110
        //acceptWidgets: function(el) { return true } // function example, but can also be: true | false | '.someClass' value
    };
    //let seriesGrid =  GridStack.init({columns: 1, rows: 1, disableOneColumnMode: true, float: true}, document.getElementById('seriesGrid'))
    //seriesGrid.addWidget({w: 12, h: 4});
    let plotGrid = GridStack.init(options, document.getElementById('plotGrid'));

    GridStack.setupDragIn('.sidebar .grid-stack-item', { appendTo: 'body', helper: myClone });

    function myClone(event) {
        const el = event.target.cloneNode(true);
        el.setAttribute('gs-id', 'foo'); // TEST why clone element is not used directly on drop #2231
        return el;
    }

    let self = this;
    var contentList = [];

    plotGrid.on('added', function(e, items) {
        // add anijs data to gridstack item
        for (let i = 0; i < items.length; i++) {
            let content=new Object();
            items[i].el.id = numItems;
            content.id = items[i].el.id;
            numItems++;
            let contentItem = items[i].el.querySelector('.grid-stack-item-content');
            content.data = [[],[]];
            content.client = new Paho.MQTT.Client('localhost', 8080, "/", content.id);
            content.myClientConnected = function(){
                console.log("connected");
                content.client.subscribe("MOTOR_CONTROLLER/mc_rl/torque_current");
            }
            content.client.connect({ onSuccess: content.myClientConnected });
            content.handleMessage=function(message){
               content.data[0].push(Date.now());
               content.data[1].push(parseInt(message.payloadString))
                /*
                if (content.data[0].length > maxDataEntries){
                    console.log('cut');
                    content.data[0].splice(0, 1);
                    for (let i = 1; i < data.length; i++){
                        content.data[i].splice(0, 1);
                    }
                }
                */

                content.plot.setData(content.data);
            };
            content.client.onMessageArrived = content.handleMessage;

            let { width, height } = contentItem.getBoundingClientRect();
            content.plot = new uPlot({
                width: width-50,
                height: height - 50,
                ...sharedOpts
            }, content.data, contentItem);
            contentList.push(content);
        }

    });

    function addWidget() {
        plotGrid.addWidget({w: 3, h: 3});
    }

    plotGrid.on('resizestop', (event, contentItem) => {

        content = contentList.find((element) => element.id === contentItem.id);
        let { width, height } = contentItem.getBoundingClientRect();
        width = width-50;
        height = height-50;
        content.plot.setSize({width, height});
    })

    const sharedOpts = {
        scales: {
            'x': {
                auto: true,
                //range: (min, max) => [data[0][0], data[0][data[0].length-1]],
            },
            'y': {
                auto: true,
                //range: (min, max) => [-50, 50],
            }
        },
        series: [
            {},
            {
                stroke: "red"
            },
        ],
    };






    //uPlot stuff
    function makeChart(data) {

        const opts = {
            title: "Graph",
            width: 1000,
            height: 400,
            scales: {
                'x': {
                    //auto: true,
                    range: (min, max) => [data[0][0], data[0][data[0].length-1]],
                },
                'y': {
                    auto: true,
                    //range: (min, max) => [-50, 50],
                }
            },
            series: [
                {},
                {
                    show: true,
                    spanGaps: true,
                    // in-legend display
                    label: "Torque Current",
                    //value: data[1][data.length],
                    stroke: "red",
                    width: 1,

                },
                {
                    show: true,
                    spanGaps: true,
                    // in-legend display
                    label: "Magnetizing Current",
                    //value: data[2][data.length],
                    stroke: "orange",
                    width: 1,

                },

            ],



        }
         uplot = new uPlot(opts, data, document.body);
    }
    //makeChart(data);

</script>
<script>
/*
// This is the function which handles received messages
function myMessageArrived(message, series) {

// Get the payload
var messageBody = message.payloadString;
if (messageBody != null) {

data[0].push(time);
time++; //im just incrementing the time series by 1 cuz idk if timestamps are included with the MQTT messages
for (let i = 1; i < data.length; i++){
if (i === series){
data[i].push(parseInt(messageBody));
}
else{
data[i].push(data[i][data[i].length-1]); //if this series isn't being updated, just add the last recorded data for that series
}
}

//removes data if there are more than graphWidth data points
if (data[0].length > graphWidth){
for (let i = 1; i < data.length; i++){
data[i].splice(0, 1);
}
}
}
console.log(data);
uplot.setData(data);
}

//helper methods
function handleClient1(message){
myMessageArrived(message, 1);
}
function handleClient2(message){
myMessageArrived(message, 2);
}
//calls handleClient when MQTT message arrives
client1.onMessageArrived = handleClient1;
client2.onMessageArrived = handleClient2;
*/
</script>
</body>
</html>

