<!-- import jquery library -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<!-- import paho MQTT library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<!-- import bootStrap library -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>


<script src="../uPlot Testing/dist/uPlot.iife.js"></script>
<script src="../uPlot Testing/node_modules/gridstack/dist/gridstack-all.js"></script>
<link rel="stylesheet" href="../uPlot Testing/node_modules/gridstack/dist/gridstack-extra.min.css"/>
<link href="../uPlot Testing/node_modules/gridstack/dist/gridstack.min.css" rel="stylesheet"/>
<script src="../uPlot Testing/dist/uPlot.iife.js"></script>

<link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
<!-- put CSS code here to edit style of uPlot? -->
<style>
    body {
        margin: 0;
    }

    .u-legend.u-inline .u-value {
        width: 50px;
        text-align: left;
    }
</style>
<style type="text/css">

    .grid-stack { background: #F2F2F2; }
    .grid-stack-item-content { background-color: #FFFFFF;
        text-align: center;}
    .btn-primary {
        color: #fff;
        background-color: #262B4A;
    }
    .sidebar {
        background: #F2F2F2;
        padding: 25px 0;
        height: auto;
        text-align: center;

    }
    .sidebar .grid-stack-item {
        width: 150px;
        height: 50px;
        margin: 5px;
        text-align: center;
        line-height: 50px;
        background: #F2F2F2;
        cursor: default;
        display: inline-block;
    }
</style>



<html>
<head>
    <meta charset="utf-8">
    <title>Data Stream</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
</head>
<body style="background-color:#FFFFFF;color:#000000;">
<body>
<div class="container-fluid">
    <br>
    <div>
        <a onClick="addWidget()" class="btn btn-primary" href="#">Add Widget</a>
    </div>

    <div class="row" style="margin-top: 20px">
        <div class="col-2">
            <div class="grid-stack" id="seriesGrid"></div>

        </div>
        <div class="col-10" >
            <div class="grid-stack" id="plotGrid"></div>
        </div>
    </div>


</div>
<script>
    let maxDataEntries = 100;
    let numItems = 0; //number of plot widgets, used to generate widget IDs
    var dataSeriesInfo;
    let startTime = Date.now();
    async function loadJson() { //loads data series info
        const response = await fetch('/dataSeriesInfo.json');
        dataSeriesInfo = await response.json();
        for (let i = 0; i < dataSeriesInfo.length; i++) {
            let name = dataSeriesInfo[i].name;
            seriesGrid.addWidget({w: 16, h: 5, content: name, id: i, locked: true, });
        }

        //this is a HACK. adds a bunch of empty widgets so that there's no space for the actual widgets to
        //move to when they're being dragged.
        for (let i = 0; i < 10; i++) {
            seriesGrid.addWidget({w: 16, h: 5, content: "", id: i, locked: true, });
        }

        console.log("Done");

    }

    loadJson();


    let options = {
        minRow: 1,
        disableOneColumnMode: true,
        float: true,
        acceptWidgets: false

        //removable: '.trash', // true or drag-out delete class
        // itemClass: 'with-lines', // test a custom additional class #2110
        //acceptWidgets: function(el) { return true } // function example, but can also be: true | false | '.someClass' value
    };
    //let seriesGrid =  GridStack.init({columns: 1, rows: 1, disableOneColumnMode: true, float: true}, document.getElementById('seriesGrid'))
    //seriesGrid.addWidget({w: 12, h: 4});
    let plotGrid = GridStack.init(options, document.getElementById('plotGrid'));
    let seriesGrid = GridStack.init({disableOneColumnMode: true, removable: false, float: false}, document.getElementById('seriesGrid'))


    let self = this;
    var contentList = []; //list of content in each GridStack widget

    plotGrid.on('added', function(e, items) {
        for (let i = 0; i < items.length; i++) {
            let content=new Object(); //content is an object that holds relevent info for the widget
            items[i].el.id = numItems;
            content.id = items[i].el.id;
            numItems++;
            let contentItem = items[i].el.querySelector('.grid-stack-item-content');
            content.data = [[]]; //data [0] is time, data[1 to x] are data series. Data series in each index given by topicIndexMap
            content.client = new Paho.MQTT.Client('localhost', 8080, "/", content.id);
            content.myClientConnected = function () {
                console.log("connected");
            }
            content.client.connect({onSuccess: content.myClientConnected});
            content.topicIndexMap = new Map(); //topicIndexMap, provides the data index given topic name
            content.numChannels = 1;

            let { width, height } = contentItem.getBoundingClientRect();
            content.plot = new uPlot({
                width: width-50,
                height: height - 50,
                ...sharedOpts
            }, content.data, contentItem);
            contentList.push(content);
        }

    });



    function addWidget() {
        plotGrid.addWidget({w: 3, h: 3});
    }

    plotGrid.on('resizestop', (event, contentItem) => {
        content = contentList.find((element) => element.id === contentItem.id); //finds content object matching resized widget
        let { width, height } = contentItem.getBoundingClientRect();
        width = width-50;
        height = height-75;
        content.plot.setSize({width, height}); //updates size
    })





    const sharedOpts = {
        pxAlign: 0,
        scales: {
            'x': {
                auto: true,
                //range: (min, max) => [data[0][0], data[0][data[0].length-1]],
            },
            'y': {
                auto: true,
                range: (min, max) => [-50, 50],
            }
        },
        series: [
            {value: "{HH}:{mm}:{ss}"}, //https://github.com/leeoniya/uPlot/issues/83#issuecomment-570416433
        ],

    };
    /*
    seriesGrid.on('drag', function(event) {
        el = el.gridstackNode;
        mouseX = event.clientX;
        mouseY = event.clientY;
        plotWidget = getWidgetAtCoord(mouseX, mouseY);
        if (plotWidget != null) {
            let contentItem = plotWidget.el.querySelector('.grid-stack-item-content');
        }
    });
    */

    seriesGrid.on('dragstop', function(event, el) {
        el = el.gridstackNode;
        mouseX = event.clientX;
        mouseY = event.clientY;
        plotWidget = getWidgetAtCoord(mouseX, mouseY);
        var content;
        if (plotWidget != null) {
            content = contentList.find((element) => element.id === plotWidget.id);
        }
        if (content != null) {
            dataSeries = dataSeriesInfo[el.id];
            content.client.subscribe(dataSeries.channel)
            if (content.numChannels === 1) { //if adding first channel to plot
                content.data.push(Array(content.data[0].length).fill(null));
                content.plot.addSeries({
                    stroke: "red", label: dataSeries.name, spanGaps: true}, content.numChannels); //not 100% sure how the 2nd parameter works
            }
            else { //if adding >= 2 channel to plot
                content.data.push(Array(content.data[0].length).fill(null));
                content.plot.addSeries({
                    stroke: "orange", label: dataSeries.name, spanGaps: true}, content.numChannels); //not 100% sure how the 2nd parameter works
            }
            content.topicIndexMap.set(dataSeries.channel, content.numChannels);
            content.numChannels++;





            content.client.onMessageArrived = function (message) {
                index = content.topicIndexMap.get(message.destinationName);
                content.data[0].push(Date.now()/1000);
                for (let i = 1; i < content.data.length; i++) {
                    if (i === index) {
                        let newDataPoint = parseInt(message.payloadString)
                        if (newDataPoint === -0) {
                            newDataPoint = 0
                        }
                        content.data[i].push(newDataPoint);
                    }
                    else {
                        content.data[i].push(content.data[i][content.data[i].length-1]);
                    }
                }
                if (content.data[0][content.data[0].length-1] - content.data[0][0] > 10){ //10 secs
                    for (let i = 0; i < content.data.length; i++) {
                        content.data[i].splice(0, 1);
                    }
                }


                content.plot.setData(content.data);

            }//content.handleMessage;

    }
    })

    function getWidgetAtCoord(x, y) {
        pos =  plotGrid.getCellFromPixel({top: mouseY, left: mouseX});
        items = plotGrid.getGridItems();
        var content = null;
        for (let i = 0; i < items.length; i++) {
            plotWidget = items[i];

            //smth be wrong with this code, fails on borders
            left = parseInt(plotWidget.getAttribute('gs-x'));
            right = left+parseInt(plotWidget.getAttribute('gs-w')-1);
            top2 = parseInt(plotWidget.getAttribute('gs-y')); //for some reason using var name top ruins everything
            bottom = top2 + parseInt(plotWidget.getAttribute('gs-h'))-1;
            if (left<= pos.x-3 && pos.x-3 <= right){ //hard-coded offset for some reason. I hate myself
                if (top2 <= pos.y-2  && pos.y-2<= bottom){
                    return plotWidget;
                }
            }
        }
    }






</script>
<script>
/*
// This is the function which handles received messages
function myMessageArrived(message, series) {

// Get the payload
var messageBody = message.payloadString;
if (messageBody != null) {

data[0].push(time);
time++; //im just incrementing the time series by 1 cuz idk if timestamps are included with the MQTT messages
for (let i = 1; i < data.length; i++){
if (i === series){
data[i].push(parseInt(messageBody));
}
else{
data[i].push(data[i][data[i].length-1]); //if this series isn't being updated, just add the last recorded data for that series
}
}

//removes data if there are more than graphWidth data points
if (data[0].length > graphWidth){
for (let i = 1; i < data.length; i++){
data[i].splice(0, 1);
}
}
}
console.log(data);
uplot.setData(data);
}

//helper methods
function handleClient1(message){
myMessageArrived(message, 1);
}
function handleClient2(message){
myMessageArrived(message, 2);
}
//calls handleClient when MQTT message arrives
client1.onMessageArrived = handleClient1;
client2.onMessageArrived = handleClient2;
*/
</script>
</body>
</html>

