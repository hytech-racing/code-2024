<!-- import jquery library -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<!-- import paho MQTT library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>

<!-- import bootStrap library -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>


<script src="../uPlot Testing/dist/uPlot.iife.js"></script>
<script src="../uPlot Testing/node_modules/gridstack/dist/gridstack-all.js"></script>
<link rel="stylesheet" href="../uPlot Testing/node_modules/gridstack/dist/gridstack-extra.min.css"/>
<link href="../uPlot Testing/node_modules/gridstack/dist/gridstack.min.css" rel="stylesheet"/>
<script src="../uPlot Testing/dist/uPlot.iife.js"></script>

<link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
<style type="text/css">

    .grid-stack { background: #F2F2F2; }
    .grid-stack-item-content { background-color: #FFFFFF;
        text-align: center;}
    .btn-primary {
        color: #fff;
        background-color: #262B4A;
    }
    .sidebar {
        background: #F2F2F2;
        padding: 25px 0;
        height: auto;
        text-align: center;

    }
    .sidebar .grid-stack-item {
        width: 150px;
        height: 50px;
        margin: 5px;
        text-align: center;
        line-height: 50px;
        background: #F2F2F2;
        cursor: default;
        display: inline-block;
    }
</style>

<html>
<head>
    <meta charset="utf-8">
    <title>Data Stream</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="../uPlot Testing/dist/uPlot.min.css">
</head>
<body style="background-color:#FFFFFF;color:#000000;">
<body>
<div class="container-fluid">
    <br>
    <div>
        <a onClick="addWidget()" class="btn btn-primary" href="#">Add Widget</a>
    </div>

    <div class="row" style="margin-top: 20px">
        <div class="col-2">
            <div class="grid-stack" id="seriesGrid"></div>
            <!--
            <div class="sidebar">

                <div class="grid-stack-item">
                    <div class="grid-stack-item-content">Series 1</div>
                </div>

                <div class="grid-stack-item" gs-w="2" gs-h="1" gs-max-w="3">
                    <div class="grid-stack-item-content">2x1, max=3</div>
                </div>
            </div>
        -->
        </div>
        <div class="col-10" >
            <div class="grid-stack" id="plotGrid"></div>
        </div>
    </div>


</div>
<script>
    let maxDataEntries = 100;
    let numItems = 0;


    let options = {
        minRow: 1,
        disableOneColumnMode: true,
        float: true,
        acceptWidgets: false
        //removable: '.trash', // true or drag-out delete class
        // itemClass: 'with-lines', // test a custom additional class #2110
        //acceptWidgets: function(el) { return true } // function example, but can also be: true | false | '.someClass' value
    };
    //let seriesGrid =  GridStack.init({columns: 1, rows: 1, disableOneColumnMode: true, float: true}, document.getElementById('seriesGrid'))
    //seriesGrid.addWidget({w: 12, h: 4});
    let plotGrid = GridStack.init(options, document.getElementById('plotGrid'));
    let seriesGrid = GridStack.init({disableOneColumnMode: true, removable: false}, document.getElementById('seriesGrid'))




    function myClone(event) {
        const el = event.target.cloneNode(true);
        el.setAttribute('gs-id', 'foo'); // TEST why clone element is not used directly on drop #2231
        return el;
    }

    let self = this;
    var contentList = [];

    plotGrid.on('added', function(e, items) {
        // add anijs data to gridstack item
        for (let i = 0; i < items.length; i++) {
            let content=new Object();
            items[i].el.id = numItems;
            content.id = items[i].el.id;
            numItems++;
            let contentItem = items[i].el.querySelector('.grid-stack-item-content');
            content.data = [[],[]];
            content.client = new Paho.MQTT.Client('localhost', 8080, "/", content.id);
            content.myClientConnected = function(){
                console.log("connected");
                content.client.subscribe("MOTOR_CONTROLLER/mc_rl/torque_current");
            }
            content.client.connect({ onSuccess: content.myClientConnected });
            content.handleMessage=function(message){
               content.data[0].push(Date.now());
               content.data[1].push(parseInt(message.payloadString))
                /*
                if (content.data[0].length > maxDataEntries){
                    console.log('cut');
                    content.data[0].splice(0, 1);
                    for (let i = 1; i < data.length; i++){
                        content.data[i].splice(0, 1);
                    }
                }
                */

                content.plot.setData(content.data);
            };
            content.client.onMessageArrived = content.handleMessage;

            let { width, height } = contentItem.getBoundingClientRect();
            content.plot = new uPlot({
                width: width-50,
                height: height - 50,
                ...sharedOpts
            }, content.data, contentItem);
            contentList.push(content);
        }

    });

    seriesGrid.on('added', function(e, items){
        for (let i = 0; i < items.length; i++) {
            let content = new Object();
            let contentItem = items[i].el.querySelector('.grid-stack-item-content');
            contentItem = "NAH";
        }
    });

    function addWidget() {
        plotGrid.addWidget({w: 3, h: 3});
    }

    plotGrid.on('resizestop', (event, contentItem) => {
        content = contentList.find((element) => element.id === contentItem.id);
        let { width, height } = contentItem.getBoundingClientRect();
        width = width-50;
        height = height-50;
        content.plot.setSize({width, height});
    })





    const sharedOpts = {
        scales: {
            'x': {
                auto: true,
                //range: (min, max) => [data[0][0], data[0][data[0].length-1]],
            },
            'y': {
                auto: true,
                //range: (min, max) => [-50, 50],
            }
        },
        series: [
            {},
            {
                stroke: "red"
            },
        ],
    };



    seriesGrid.on('dragstop', function(event) {
        mouseX = event.clientX;
        mouseY = event.clientY;
        pos =  plotGrid.getCellFromPixel({top: mouseY, left: mouseX});
        items = plotGrid.getGridItems();
        for (let i = 0; i < items.length; i++) {
            el = items[i];
            left = parseInt(el.getAttribute('gs-x'));
            right = left+parseInt(el.getAttribute('gs-w'));
            top2 = parseInt(el.getAttribute('gs-y')); //for some reason using var name top ruins everything
            bottom = top2 + parseInt(el.getAttribute('gs-h'));
            if (left<= pos.x-2 && pos.x-2 <= right){ //hard-coded offset for some reason. I hate myself
                if (top2 <= pos.y-2  && pos.y-2<= bottom){
                    console.log("ID" + el.id);
                }
            }
        }
    });
    let series = "Temperature"
    seriesGrid.addWidget({w: 14, h: 5, content: series, id: series});


</script>
<script>
/*
// This is the function which handles received messages
function myMessageArrived(message, series) {

// Get the payload
var messageBody = message.payloadString;
if (messageBody != null) {

data[0].push(time);
time++; //im just incrementing the time series by 1 cuz idk if timestamps are included with the MQTT messages
for (let i = 1; i < data.length; i++){
if (i === series){
data[i].push(parseInt(messageBody));
}
else{
data[i].push(data[i][data[i].length-1]); //if this series isn't being updated, just add the last recorded data for that series
}
}

//removes data if there are more than graphWidth data points
if (data[0].length > graphWidth){
for (let i = 1; i < data.length; i++){
data[i].splice(0, 1);
}
}
}
console.log(data);
uplot.setData(data);
}

//helper methods
function handleClient1(message){
myMessageArrived(message, 1);
}
function handleClient2(message){
myMessageArrived(message, 2);
}
//calls handleClient when MQTT message arrives
client1.onMessageArrived = handleClient1;
client2.onMessageArrived = handleClient2;
*/
</script>
</body>
</html>

